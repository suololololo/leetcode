# 285周周赛

<h2> problem A:[统计数组中峰和谷的数量](https://leetcode-cn.com/problems/count-hills-and-valleys-in-an-array/) </h2><br>

<h2> 解法:模拟</h2></br>

给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。

注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。<br>
```cpp
class Solution
{
public:
    int countHillValley(vector<int>& nums)
    {
        int res = 0;
        int n = nums.size();
        int predHill = -1;
        for(int i = 0; i < n; i++)
        {
            int pred = i -1;
            int next = i + 1;
            while(pred >= 0 && next < n)
            {
                if (nums[i] != nums[pred] && nums[i] != nums[next])
                    break;
                if (nums[i] == nums[pred])
                    pred--;
                if (nums[i] == nums[next])
                    next++;
            }
            if (pred >= 0 && next < n)
            {
                if (predHill >= 0 && nums[predHill] == nums[i])
                    continue;
                if (nums[i] > nums[pred] && nums[i] > nums[next])
                {
                    predHill = i;
                    res++;
                }

                if (nums[i] < nums[pred] && nums[i] < nums[next])
                {
                    predHill = i;
                    res++;
                }

            }
        }
        return res;
    } 

}


```


<h2> problem B:[统计道路上的碰撞次数](https://leetcode-cn.com/problems/count-collisions-on-a-road/)</h2>
<h2> 解法:模拟 脑筋急转弯</h2></br> **卡在了这里，做的时候想复杂了， 尝试了dfs，模拟没做出来，还是代码水平不够** </br>
对于L的车辆，只要左边有R或S就一定会撞上，对于R的车辆，只要右边有L或S就一定会撞上，所以直接进行统计

```cpp
class Solution
{
public:
    int countCollisions(string directions)
    {
        int res = 0;
        bool flag = false;
        for (char c : directions)
        {
            if (c == 'R' || c == 'S')
                flag = true;
            else if(flag)
                res++;
        }
        flag = false;
        for(int i = directions.size() - 1; i >= 0; i--)
        {
            if (directions[i] == 'L' || directions[i]  == 'S')
                flag = true;
            else if (flag)
                res++;
        }
        return res;
    }
}
```

<h2> problem c:[射箭比赛中的最大得分](https://leetcode-cn.com/problems/maximum-points-in-an-archery-competition/)</h2>
<h2>解法:二进制枚举</h2> 
<br>看到题目后没有思路<br>

二进制枚举，本题中用于枚举每个区间bob的得分状态，用一个bit表示某个区间是否得分，总共的枚举集合有$2^n$个,因为每个区间有两种状态，得分与不得分，所以一共是$2^n$个

```cpp
class Solution
{
    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows)
    {
        int n = aliceArrows.size();
        int res = 0;
        vector<int> ans(n);
        // 枚举 2**n个集合
        for(int i = 0; i < (1 << n); i++)
        {
            int tot = 0, score = 0;
            // 解析枚举状态
            for(int j = 0; j < n; j++)
            {
                if((i >> j) &1)
                {
                    tot += aliceArrows[j] +1;
                    score += j; 
                }
            }
            if (tot <= numArrows && score > res)
            {
                for(int j = 0; j < n; j++)
                {
                    if((i >>j) &1)
                    {
                        ans[j] = aliceArrows[j] +1;
                        
                    }
                }
                ans[n-1] += numArrows - tot; 
            }

        }
        return ans;
    }
}

```